<!DOCTYPE html>
<html>
  <head>
    <title>Linked Data Patch</title>
    <meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "ld-patch",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI:           "http://berjon.com/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              {
                  name:       "Alexandre Bertails"
              ,   url:        "http://bertails.org/"
              ,   mailto:     "alexandre@bertails.org"
              ,   company:    "Pellucid Analytics"
              ,   companyURL: "http://www.pellucid.com"
              },
              {
                  name:       "Andrei Sambra"
              ,   url:        "https://deiu.rww.io/profile/card#me"
              ,   mailto:     "andrei@fcns.eu"
              ,   company:    "MIT"
              ,   companyURL: "http://web.mit.edu"
              },
          ],
          
          // name of the WG
          wg:           "The Linked Data enthusiasts",
          
          // URI of the public WG page
          wgURI:        "https://github.com/ld-specs",
          
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "spec-writers-anonymous",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
          // !!!! IMPORTANT !!!! MAKE THE ABOVE BLINK IN YOUR HEAD
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        Linked Data Patch (LD Patch) is a patch format for Linked Data.
      </p>
    </section>
    
    <section id='sotd'>
      <p>
        @@You need to have a custom SotD paragraph. Maybe give a succinct description of your spec's
        status.@@
      </p>
    </section>
    
    <section id='introduction'>
      <h2>Introduction</h2>
      <p>
        This specification defines Linked Data Patch (LD Patch), a patch format for Linked Data. It is intended to be used with the <a href="https://tools.ietf.org/html/rfc5789">PATCH Method for HTTP</a> but not limited to. This specification includes a concrete syntax, an abstract model and an operational semantics for LD Patch.
      </p>
      <p id='expressive-power'>
        The scope of LD Patch is intentionally limited when compared to SPARQL Update capabilities. Its expressive power is limited to (relative) RDF Graphs. Matching nodes is achieved using property paths. Nodes can be bound to variables. The language includes support for blank nodes and RDF Lists.
      </p>
      <p id='design-choices'>
        The authors of the document made conscious choices when designing the LD Patch language. Here are a few:
        <ul>
          <li>LD Patch was thought to be used in Linked Data applications. It is <strong>not</strong> designed for general purpose RDF applications.</li>
          <li>if more expressive power is desired, the authors recommends the use of SPARQL Update.</li>
          <li>LD Patch is not design to describe diffs between RDF Graphs: it is meants to be used in applications as a real patching language. That being said, it is strongly inspired from <a href="http://afs.github.io/rdf-patch/">RDF Patch</a> and is (mostly?) a superset.</li>
          <li>compatibity with SPARQL Update was not sought as there is no intention to make LD Patch's semantics a subset of SPARQL Update's. As a result, an LDP Patch instance is not a valid SPARQL update query.</li>
          <li>being able to match Blank Nodes is a desired and non-negociable property</li>
          <li>good performance characteristics of the operational semantics requires some trade-offs in the features of the language.</li>
          <li></li>
        </ul>
      </p>
    </section>

    <section id='terminology'>
      <h2>Terminology</h2>
      <p>
      </p>
      <dl class="glossary">
        <dt>Linked Data</dt>
        <dd></dd>
        <dt>Property path</dt>
        <dd></dd>
        <dt>Concrete Syntax</dt>
        <dd></dd>
        <dt>Abstract Syntax</dt>
        <dd></dd>
        <dt>Operational Semantics</dt>
        <dd></dd>
        <dt></dt>
        <dd></dd>
        <dt></dt>
        <dd></dd>
      </dl>
    </section>

    <section id='examples'>
      <h2>LD Patch examples</h2>

      <p>Input Graph</p>

      <pre class="example">
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

[] foaf:name "Alexandre" ;
  foaf:knows <http://bblfish.net/#hjs> .

<http://bblfish.net/#hjs> foaf:name "Henry Story" ;
  foaf:currentProject <http://webid.info/> .          
      </pre>

      <p>@@</p>

      <pre class="example">
DELETE {
  <http://bblfish.net/#hjs> ?p ?o
}
WHERE {
  <http://bblfish.net/#hjs> ?p ?o
}
      </pre>

      <p>Expected Graph</p>

      <pre class="example">
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
[] foaf:name "Alex" ;
  foaf:knows <http://bblfish.net/#hjs> .
      </pre>

      <pre class="example">

      </pre>

      <pre class="example">

      </pre>

    </section>

    <section id='concrete-syntax'>
      <h2>Concrete Syntax</h2>
      <p>
      </p>
    </section>

    <section id='abstract-syntax'>
      <h2>Abstract Syntax</h2>
      <p>
      </p>
      <pre>
Add <startingNode>/<p1>/<p2>\<p3>! <predicateToAdd> "valueToAdd" .
Add <startingNode> <predicateToAdd> "valueToAdd" .
Delete <startingNode>/<p1>/<p2>\<p3>! <predicate> "valueToAdd" .
Delete <startingNode>/<p1>/<p2>\<p3>! -<predicate> "valueToAdd" .
Delete <startingNode>/<p1>/<p2>\<p3>! <predicate> .
Update <startingNode>/<p1>/<p2>\<p3>! <predicate> "v1" "v2" .
Bind <startingNode>/<p1>/<p2>\<p3>! ?v .
(+ list)

Bind <startingNode>/<p1>/<p2>\<p3>! ?v
Add ?v <predicateToAdd> _:b1 .
Add _:b1 <foo> <bar> .

Bind <startingNode>/<p1>/<p2>\<p3>! [ <foo> <bar> ] .

NodeSet
f: (NodeSet, Path) -> NodeSet
f: ???             -> NodeSet

LDPatch             ::= List(Statement)
Statement           ::= Bind | Add | Delete | Update
Bind                ::= ((VarOrConcreteNode, Path), Var)
Add                 ::= ((VarOrConcreteNode, Path), OrientedPredicate, Node)
Delete              ::= ((VarOrConcreteNode, Path), OrientedPredicate, Option(Node))
Update              ::= ((VarOrConcreteNode, Path), OrientedPredicate, Node, Node)
OrientedPredicate   ::= (Direction, Uri)
VarOrConcreteNode   ::= Var | ConcreteNode
ConcreteNode        ::= Uri | Literal
Node                ::= Uri | Bnode | Literal
Path                ::= List(PathElement)
PathElement         ::= (Direction, Uri, MatchingMode)
Direction           ::= Forward | BackWard
MatchingMode        ::= Single | Multiple

Note:
* no support for [i, j]
* [i] happens at parsing

Option(T) ::= Some(T) | None

      </pre>

    </section>
    
    <section id='operational-semantics'>
      <h2>Operational Semantics</h2>
      <p>      
<pre>An Env(ironment) is a Map from Var-s to Node-s
Env      ::= Map(Var, Set(Node))

TBD
---

env[x]
env[x -> nodes]

matchTriples: Graph -> Option(Node) -> Uri -> Option(Node) -> Set((Node, Uri, Node))
matchTriples: (g: Graph) -> (s: Option(Node)) -> (p: Uri) -> (o: Option(Node)) -> { matchingTriples: Set((Node, Uri, Node)) | triple matches the pattern (s, p, o) in g -> triple ∈ matchingNodes }

+: Graph -> Set(Triple) -> Graph

-: Graph -> Set(Triple) -> Graph

sem functions
-------------

sem_varOrConcreteNode is a function that maps a Var to a Node or a ConcreteNode to itself
sem_varOrConcreteNode: Env -> VarOrConcreteNode -> Set(Node)
sem_varOrConcreteNode(env, v: Var) = env[v]
sem_varOrConcreteNode(env, uri: Uri) = Set(uri)
sem_varOrConcreteNode(env, literal: Literal) = Set(literal)

sem_matchingNodes: Graph -> Set(Node) -> Path -> Set(Node)
sem_matchingNodes(graph, nodes, List()) = nodes
sem_matchingNodes(graph, nodes, (Forward, uri, mode) :: restPath) =
  let triples = { matchTriples(graph, node, uri, ANY) | node ∈ nodes } in
  let matchingNodes = { o | (s, p, o) ∈ triples } in
  if mode is Single and size(matchingNodes) is not 1 then throw error
  sem_matchingNodes(graph, matchingNodes, restPath)
sem_matchingNodes(graph, nodes, (Backward, uri, mode) :: restPath) =
  let triples = { matchTriples(graph, ANY, uri, node) | node ∈ nodes } in
  let matchingNodes = { s | (s, p, o) ∈ triples } in
  if mode is Single and size(matchingNodes) is not 1 then throw error
  sem_matchingNodes(graph, matchingNodes, restPath)

makeTriples: Set(Node) -> OrientedPredicate -> Node -> Set(Triple)
makeTriples(nodes, (Forward, uri), node) =
  { (n, uri, node) | n ∈ nodes }
makeTriples(nodes, (Backward, uri), node) =
  { (node, uri, n) | n ∈ nodes }


sem_bind: (Env, Graph) -> Bind -> (Env, Graph)
sem_bind((env, graph), Bind(start, path, v)) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in
  (env[v -> nodes], graph)

sem_add: (Env, Graph) -> Add -> (Env, Graph)
sem_add((env, graph), Add(start, path, orientedPredicate, node)) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in  
  let triples = makeTriples(nodes, orientedPredicate, node) in
  (env, graph + triples)


sem_delete: (Env, Graph) -> Delete -> (Env, Graph)
sem_delete((env, graph), Delete(start, path, orientedPredicate, optionalNode)) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in
  let triples = { matchTriples(graph, node, orientedPredicate, optionalNode) | node ∈ nodes } in
  (env, graph - triples)


sem_update: (Env, Graph) -> Update -> (Env, Graph)
sem_update((env, graph), Update(start, path, orientedPredicate, node1, node2)) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in
  let triplesToRemove = { matchTriples(graph, node, orientedPredicate, optionalNode) | node ∈ nodes } in
  let triplesToAdd = makeTriples(nodes, orientedPredicate, node2) in
  (env, graph - triplesToRemove + triplesToAdd)

sem_patch: Graph -> List(Statement) -> Graph
sem_patch(g, statements) = sem_patch_state(({}, g), statements)

sem_statement: (Env, Graph) -> Statement -> (Env, Graph)
sem_statement(state, bind: Bind) = sem_bind(state, bind)
sem_statement(state, add: Add) = sem_bind(state, add)
sem_statement(state, delete: Delete) = sem_bind(state, delete)
sem_statement(state, update: Update) = sem_bind(state, update)

sem_patch_state: (Env, Graph) -> List(Statement) -> Graph
sem_patch_state((env, graph), List()) = graph
sem_patch_state(state, statement :: restStatements) =
  let newState = sem_statement(state, statement) in
  sem_patch_state(newState, restStatements)




TODO:
* runtime error
* parsing error
* grammar
* lists

        </pre>
      </p>
    </section>
    

  </body>
</html>
