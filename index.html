<!DOCTYPE html>
<html>
  <head>
    <title>Linked Data Patch Format</title>
    <meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "ld-patch",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI:           "http://berjon.com/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              {
                  name:       "Alexandre Bertails"
              ,   url:        "http://bertails.org/"
              ,   mailto:     "alexandre@bertails.org"
              ,   company:    "Pellucid Analytics"
              ,   companyURL: "http://www.pellucid.com"
              },
              {
                  name:       "Pierre-Antoine Champin"
              ,   url:        "http://liris.cnrs.fr/~pchampin/en/"
//              ,   mailto:     "@@@"
              ,   company:    "Université de Lyon"
//              ,   companyURL: "@@@"
              },
              {
                  name:       "Andrei Sambra"
              ,   url:        "https://deiu.rww.io/profile/card#me"
              ,   mailto:     "asambra@mit.edu"
              ,   company:    "MIT"
              ,   companyURL: "http://web.mit.edu"
              },
          ],

          // name of the WG
          wg:           "Linked Data Platform Working Group",
          
          // URI of the public WG page
          wgURI:        "http://www.w3.org/2012/ldp",
          
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-ldp-comments",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/Consortium/Patent-Policy-20040205/",
          // !!!! IMPORTANT !!!! MAKE THE ABOVE BLINK IN YOUR HEAD
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
Linked Data Patch Format (LD Patch) defines a language for expressing a sequence of operations to apply to a RDF Graph; it is suitable for use with the HTTP PATCH method. The "text/ldpatch" media type is used to identify such Patch documents.
      </p>
    </section>
    
    <section id='sotd'>
      <p>
        @@You need to have a custom SotD paragraph. Maybe give a succinct description of your spec's
        status.@@
      </p>
    </section>
    
    <section class='informative' id='introduction'>
      <h1>Introduction</h1>
      <p>
Linked Data "describes a method of publishing structured data so that it can be interlinked and become more useful. It builds upon standard Web technologies such as HTTP, RDF and URIs, but rather than using them to serve web pages for human readers, it extends them to share information in a way that can be read automatically by computers. This enables data from different sources to be connected and queried." (source Wikipedia).
      </p>
      <p>
This document defines the Linked Data Patch Format (LD Patch), a patch format for Linked Data. It is suitable for use with HTTP PATCH [@@RFC5789], a method to perform partial modifications to Web resources. The "text/ldpatch" media type is used to identify such LD Patch documents.
      </p>
      <p>
An instance of the LD Patch language (or LD Patch document) defines a list of operations to be performed against an RDF Graph. Operations include @@@. They operate on nodes and triples belonging to the graph.
      </p>
      <p>
        The following RDF Graph will be used as an example through this specification. It describes the relation between a person named Tim Berners-Lee (denoted by &lt;http://example.org/timbl#&gt;) and two events he attended.
      </p>
      <pre class='example'>
@prefix schema: &lt;http://schema.org/&gt; .
@prefix profile: &lt;http://ogp.me/ns/profile#&gt; .

&lt;http://example.org/timbl#&gt; a schema:Person ;
  schema:alternateName "TimBL" ;
  profile:first_name "Tim" ;
  profile:last_name "Berners-Lee" ;
  schema:workLocation [ schema:name "W3C/MIT" ] ;
  schema:attendee _:b1, _:b2 .

_:b1  ;
  schema:name "F2F5 - Linked Data Platform" ;
  schema:url &lt;https://www.w3.org/2012/ldp/wiki/F2F5&gt; .

_:b2 a schema:Event ;
  schema:name "TED 2009" ;
  schema:startDate "2009-02-04" .
  schema:url &lt;http://conferences.ted.com/TED2009/&gt; .
      </pre>
      <p>
The following is an example LD Patch document, transferred in an HTTP PATCH request:
      </p>
      <pre class='example'>
PATCH /timbl HTTP/1.1
Host: example.org
Content-Length: 326@@
Content-Type: text/ldpatch
If-Match: "abc123"

@prefix profile: &lt;http://ogp.me/ns/profile#&gt; .

Replace &lt;#&gt; profile:first_name 0> ( "Timothy" ) .

Bind ?event &lt;#&gt; schema:attendee .
Add ?event rdf:type schema:Event .

Bind ?ted &lt;http://conferences.ted.com/TED2009/&gt; /-schema:url! .
Delete ?ted schema:startDate "2009-02-04".
Add ?ted schema:location [
  schema:name "Long Beach, California";
  schema:geo [ schema:latitude "33.7817" ; schema:longitude "-118.2054" ] .
] .
      </pre>
      <p>
This example introduces many of features of the LD Patch format: @prefix and prefixed names, the @@@ operations, the Bind-ing mechanism, @@@.
      </p>
      <p>
The following is the resulting (patched) document.
      </p>
      <pre class='example'>
@prefix schema: &lt;http://schema.org/&gt; .
@prefix profile: &lt;http://ogp.me/ns/profile#&gt; .

&lt;http://example.org/timbl#&gt; a schema:Person ;
  schema:alternateName "TimBL" ;
  profile:first_name "Timothy" ;
  profile:last_name "Berners-Lee" ;
  schema:workLocation [ schema:name "W3C/MIT" ] ;
  schema:attendee _:b1, _:b2 .

_:b1  ;
  schema:name "F2F5 - Linked Data Platform" ;
  schema:url &lt;https://www.w3.org/2012/ldp/wiki/F2F5&gt; .

_:b2 a schema:Event ;
  schema:name "TED 2009" ;
  schema:url &lt;http://conferences.ted.com/TED2009/&gt; ;
  schema:location [
    schema:name "Long Beach, California";
    schema:geo [ schema:latitude "33.7817" ; schema:longitude "-118.2054" ] .
  ] .
      </pre>


    </section>

<!--      <p id='expressive-power'>
        The scope of LD Patch is intentionally limited when compared to SPARQL Update capabilities. Its expressive power is limited to (relative) RDF Graphs. Matching nodes is achieved using property paths. Nodes can be bound to variables. The language includes support for blank nodes and RDF Lists.
      </p>
      <p id='design-choices'>
        The authors of the document made conscious choices when designing the LD Patch language. Here are a few:
        <ul>
          <li>LD Patch was thought to be used in Linked Data applications. It is <strong>not</strong> designed for general purpose RDF applications.</li>
          <li>if more expressive power is desired, the authors recommends the use of SPARQL Update.</li>
          <li>LD Patch is not design to describe diffs between RDF Graphs: it is meants to be used in applications as a real patching language. That being said, it is strongly inspired from <a href="http://afs.github.io/rdf-patch/">RDF Patch</a> and is (mostly?) a superset.</li>
          <li>compatibity with SPARQL Update was not sought as there is no intention to make LD Patch's semantics a subset of SPARQL Update's. As a result, an LDP Patch instance is not a valid SPARQL update query.</li>
          <li>being able to match Blank Nodes is a desired and non-negociable property</li>
          <li>good performance characteristics of the operational semantics requires some trade-offs in the features of the language.</li>
          <li></li>
        </ul>
      </p>

-->

       
    <section class='informative' id='language-features'>
      <h1>LD Patch format</h1>
      <p>
A LD Patch document is made of a list of statements, where the order is relevant. Each statement either binds a variable to a set of matching nodes, or defines a modification on the graph.
      </p>
      <p>

      </p>
      <h2>Prefixes</h2>
      <p>

      </p>
      <h2>Path expressions</h2>
      <h2>Node matching semantics</h2>
      <h2>Pointed Graph</h2>
      <h2>Bind</h2>
      <h2>Add</h2>
      <h2>Delete</h2>
      <h2>Cut</h2>
      <h2>Update</h2>
    </section>


    <section id='concrete-syntax'>
      <h1>Concrete Syntax</h1>
      <p>
      </p>
      <pre>
LDPatch ::= Prologue Statement*
Prologue ::= Prefix*
Prefix ::= "Prefix" PNAME_NS IRIREF
Statement ::= Bind | Add | Delete | Replace
Bind ::= "Bind" Var Value Path?
Add ::= "Add" Subject Predicate ( Object | List )
Delete ::= "Delete" Subject Predicate Object
Replace ::= "Replace" Subject Predicate Slice List

Subject ::= iri | BlankNode | Var
Predicate ::= iri
Object ::= iri | BlankNode | literal | Var
Value ::= iri | literal | Var
List ::= '(' Object* ')'

Path ::= ( Step | Constraint )*
Step ::= '/' ( '-' iri | iri | INDEX )
Constraint ::= '[' Path ( '=' Value )? ']' | '!'

Slice ::= INDEX? '&gt;' INDEX?
INDEX ::= [0-9]+

// copied from SPARQL

// supposed to be `Var ::= VAR1 | VAR2` but here only VAR1
Var ::= '?' VARNAME
VARNAME ::= ( PN_CHARS_U | [0-9] ) ( PN_CHARS_U | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*

// copied from Turtle

literal ::= RDFLiteral | NumericLiteral | BooleanLiteral
NumericLiteral ::= INTEGER | DECIMAL | DOUBLE
RDFLiteral ::= String (LANGTAG | '^^' iri)?
BooleanLiteral ::= 'true' | 'false'
String ::= STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE | STRING_LITERAL_LONG_SINGLE_QUOTE | STRING_LITERAL_LONG_QUOTE
iri ::= IRIREF | PrefixedName
PrefixedName ::= PNAME_LN | PNAME_NS
BlankNode ::= BLANK_NODE_LABEL | ANON
IRIREF ::= '&lt;' ([^#x00-#x20&lt;&gt;"{}|^`\] | UCHAR)* '&gt;' /* #x00=NULL #01-#x1F=control codes #x20=space */
PNAME_NS ::= PN_PREFIX? ':'
PNAME_LN ::= PNAME_NS PN_LOCAL
BLANK_NODE_LABEL ::= '_:' (PN_CHARS_U | [0-9]) ((PN_CHARS | '.')* PN_CHARS)?
LANGTAG ::= '@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*
INTEGER ::= [+-]? [0-9]+
DECIMAL ::= [+-]? [0-9]* '.' [0-9]+
DOUBLE ::= [+-]? ([0-9]+ '.' [0-9]* EXPONENT | '.' [0-9]+ EXPONENT | [0-9]+ EXPONENT)
EXPONENT ::= [eE] [+-]? [0-9]+
STRING_LITERAL_QUOTE ::= '"' ([^#x22#x5C#xA#xD] | ECHAR | UCHAR)* '"'      /* #x22=" #x5C=\ #xA=new line #xD=carriage return */
STRING_LITERAL_SINGLE_QUOTE ::= "'" ([^#x27#x5C#xA#xD] | ECHAR | UCHAR)* "'"      /* #x27=' #x5C=\ #xA=new line #xD=carriage return */
STRING_LITERAL_LONG_SINGLE_QUOTE ::= "'''" (("'" | "''")? ([^'\] | ECHAR | UCHAR))* "'''"
STRING_LITERAL_LONG_QUOTE ::= '"""' (('"' | '""')? ([^"\] | ECHAR | UCHAR))* '"""'
UCHAR ::= '\\u' HEX HEX HEX HEX | '\\U' HEX HEX HEX HEX HEX HEX HEX HEX
ECHAR ::= '\' [tbnrf"'\]
WS ::= #x20 | #x9 | #xD | #xA /* #x20=space #x9=character tabulation #xD=carriage return #xA=new line */
ANON ::= '[' WS* ']'
PN_CHARS_BASE ::= [A-Z] | [a-z] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF] | [#x0370-#x037D] | [#x037F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
PN_CHARS_U ::= PN_CHARS_BASE | '_'
PN_CHARS ::= PN_CHARS_U | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]
PN_PREFIX ::= PN_CHARS_BASE ((PN_CHARS | '.')* PN_CHARS)?
PN_LOCAL ::= (PN_CHARS_U | ':' | [0-9] | PLX) ((PN_CHARS | '.' | ':' | PLX)* (PN_CHARS | ':' | PLX))?
PLX ::= PERCENT | PN_LOCAL_ESC
PERCENT ::= '%' HEX HEX
HEX ::= [0-9] | [A-F] | [a-f]
PN_LOCAL_ESC ::= '\' ('_' | '~' | '.' | '-' | '!' | '$' | '&amp;' | "'" | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%')
      </pre>
    </section>

    <section id='abstract-syntax'>
      <h1>Abstract Syntax</h1>
      <p>
The LD Patch data model makes use of the commonly defined <a href="http://en.wikipedia.org/wiki/Abstract_data_type">Abstract Data Types</a> <a href="http://en.wikipedia.org/wiki/Set_(computer_science)">Set</a>, <a href="http://en.wikipedia.org/wiki/List_(computer_science)">List</a> and <a href="http://en.wikipedia.org/wiki/Option_type">Option</a>, used here as type constructors. For example, <code>Set(A)</code> denotes the type for the sets of elements of type <code>A</code>. We assume that they come with their common operations, such as the function <code>size&nbsp;:&nbsp;Set&nbsp;→&nbsp;Int</code>.					
      </p>
      <pre>
LDPatch ::= List(Statement)

Statement ::= Add | AddList | Delete | Bind | Replace
Add       ::= (Subject, Predicate, Object)
AddList   ::= (Subject, Predicate, List(Object))
Delete    ::= (Subject, Predicate, Object)
Bind      ::= (Var, Value, Path)
Replace   ::= (Subject, Predicate, Slice, List(Object))

Path         ::= List(PathElement)
PathElement  ::= Step | Constraint
Step         ::= StepForward | StepBackward | StepAt
Constraint   ::= Filter | UNICITY_CONSTRAINT
StepForward  ::= IRI
StepBackward ::= IRI
StepAt       ::= Integer
Filter       ::= (Path, Option(Value))

Slice            ::= Range | EverythingBefore | EverythingAfter | END
Range            ::= (Integer, Integer)
EverythingBefore ::= Integer
EverythingAfter  ::= Integer

Subject   ::= IRI | BlankNode | Var
Predicate ::= IRI
Object    ::= IRI | BlankNode | Literal | Var
Value     ::= IRI | Literal | Var

Var       ::= String
IRI       ::= RDF URI-reference http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#section-IRIs as subsequently restricted by SPARQL http://www.w3.org/TR/rdf-sparql-query/#docTerminology
BlankNode ::= RDF blank node http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#section-blank-nodes
Literal   ::= RDF Literal http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#section-Graph-Literal
String    ::= a Unicode String
      </pre>

    </section>
    
    <section id='operational-semantics'>
      <h1>Operational Semantics</h1>
      <p>
The denotational RDF semantics makes use of the <a href="http://en.wikipedia.org/wiki/Set-builder_notation">set-builder notation</a> for building the RDF sets.
      </p>
<!--pre>An Env(ironment) is a Map from Var-s to Node-s
Env      ::= Map(Var, Set(Node))

TBD
---

env[x]
env[x -> nodes]

matchTriples: Graph -> Option(Node) -> Uri -> Option(Node) -> Set((Node, Uri, Node))
matchTriples: (g: Graph) -> (s: Option(Node)) -> (p: Uri) -> (o: Option(Node)) -> { matchingTriples: Set((Node, Uri, Node)) | triple matches the pattern (s, p, o) in g -> triple ∈ matchingNodes }

+: Graph -> Set(Triple) -> Graph

-: Graph -> Set(Triple) -> Graph

sem functions
-------------

sem_varOrConcreteNode is a function that maps a Var to a Node or a ConcreteNode to itself
sem_varOrConcreteNode: Env -> VarOrConcreteNode -> Set(Node)
sem_varOrConcreteNode(env, v: Var) = env[v]
sem_varOrConcreteNode(env, uri: Uri) = Set(uri)
sem_varOrConcreteNode(env, literal: Literal) = Set(literal)

sem_matchingNodes: Graph -> Set(Node) -> Path -> Set(Node)
sem_matchingNodes(graph, nodes, List()) = nodes
sem_matchingNodes(graph, nodes, (Forward, uri, mode) :: restPath) =
  let triples = { matchTriples(graph, node, uri, ANY) | node ∈ nodes } in
  let matchingNodes = { o | (s, p, o) ∈ triples } in
  if mode is Single and size(matchingNodes) is not 1 then throw error
  sem_matchingNodes(graph, matchingNodes, restPath)
sem_matchingNodes(graph, nodes, (Backward, uri, mode) :: restPath) =
  let triples = { matchTriples(graph, ANY, uri, node) | node ∈ nodes } in
  let matchingNodes = { s | (s, p, o) ∈ triples } in
  if mode is Single and size(matchingNodes) is not 1 then throw error
  sem_matchingNodes(graph, matchingNodes, restPath)

makeTriples: Set(Node) -> OrientedPredicate -> Node -> Set(Triple)
makeTriples(nodes, (Forward, uri), node) =
  { (n, uri, node) | n ∈ nodes }
makeTriples(nodes, (Backward, uri), node) =
  { (node, uri, n) | n ∈ nodes }


sem_bind: (Env, Graph) -> Bind -> (Env, Graph)
sem_bind((env, graph), Bind(start, path, v)) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in
  (env[v -> nodes], graph)

sem_add: (Env, Graph) -> Add -> (Env, Graph)
sem_add((env, graph), Add(start, path, orientedPredicate, (node, pgTriples))) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in  
  let triples = makeTriples(nodes, orientedPredicate, node) in
  (env, graph + triples + pgTriples)


sem_delete: (Env, Graph) -> Delete -> (Env, Graph)
sem_delete((env, graph), Delete(start, path, orientedPredicate, None)) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in
  let triples = { matchTriples(graph, node, orientedPredicate, None) | node ∈ nodes } in
  (env, graph - triples)
sem_delete((env, graph), Delete(start, path, orientedPredicate, Some((node, pgTriples)))) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in
  let triples = { matchTriples(graph, node, orientedPredicate, Some(node)) | node ∈ nodes } in
  (env, graph - triples - pgTriples)

sem_cut: (Env, Graph) -> Cut -> (Env, Graph)
sem_cut((env, graph), Cut(varOrConcreteNode)) =
  let nodes = sem_varOrConcreteNode(graph, env, varConcreteNode) in
  let triples = connectedGraph(nodes) in
  (env, graph = triples)


connectedGraph: Graph -> Set(Node) -> Set(Triple)
connectedGraph(graph, nodes) =
  let f(triples) = { matchingTriples(o, None, None)  | (s, p, o) ∈ triples } in
  fixpoint f


sem_update: (Env, Graph) -> Update -> (Env, Graph)
sem_update((env, graph), Update(varOrConcreteNode, (pgNode, pgTriples))) =
  let nodes = sem_varOrConcreteNode(graph, env, varOrConcreteNode) in
  let incomingTriples = { matchingTriples(None, None, node) | node ∈ nodes } in
  let newIncomingTriples = { (s, p, pgNode) | (s, p, _) ∈ incomingTriples } in
  let connectedTriples = connectedGraph(nodes) in
  (env, graph - incomingTriples - connectedTriples + newIncomingTriples + pgTriples)

sem_patch: Graph -> List(Statement) -> Graph
sem_patch(g, statements) = sem_patch_state(({}, g), statements)

sem_statement: (Env, Graph) -> Statement -> (Env, Graph)
sem_statement(state, bind: Bind) = sem_bind(state, bind)
sem_statement(state, add: Add) = sem_bind(state, add)
sem_statement(state, delete: Delete) = sem_bind(state, delete)
sem_statement(state, update: Update) = sem_bind(state, update)

sem_patch_state: (Env, Graph) -> List(Statement) -> Graph
sem_patch_state((env, graph), List()) = graph
sem_patch_state(state, statement :: restStatements) =
  let newState = sem_statement(state, statement) in
  sem_patch_state(newState, restStatements)




TODO:
* runtime error
* parsing error
* grammar
* lists
* examples
* best practices

        </pre-->
    </section>
    

  </body>
</html>
