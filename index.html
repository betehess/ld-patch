<!DOCTYPE html>
<html>
  <head>
    <title>Linked Data Patch Format</title>
    <meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <script class='remove'>
      var preProc = {
        apply: function(c) {
                  // terms definitions
                  refs = document.querySelectorAll('tdef') ;
                  for (var i = 0; i < refs.length; i++) {
                      var item = refs[i];
                      if (!item) continue ;
                      var p = item.parentNode ;
                      var con = item.innerHTML ;
                      var ref = item.getAttribute('title') ;
                      if (!ref) {
                          ref = item.textContent ;
                      }
                      if (ref) {
                          ref = ref.replace(/\n/g, '_') ;
                          ref = ref.replace(/\s+/g, '_') ;
                      }
                      var sp = document.createElement( 'dfn' ) ;
                      sp.title = ref ;
                      sp.innerHTML = con ;
                      p.replaceChild(sp, item) ;
                  }
                  // term references
                  refs = document.querySelectorAll('tref') ;
                  for (var i = 0; i < refs.length; i++) {
                      var item = refs[i];
                      if (!item) continue ;
                      var p = item.parentNode ;
                      var con = item.innerHTML ;
                      var ref = item.getAttribute('title') ;
                      if (!ref) {
                          ref = item.textContent ;
                      }
                      if (ref) {
                          ref = ref.replace(/\n/g, '_') ;
                          ref = ref.replace(/\s+/g, '_') ;
                      }

                      var sp = document.createElement( 'a' ) ;
                      var id = item.textContent ;
                      sp.className = 'tref' ;
                      sp.title = ref ;
                      sp.innerHTML = con ;
                      p.replaceChild(sp, item) ;
                  }
              }
      };

      function updateExample(doc, content) {
        // perform transformations to make it render and prettier
        content = content.replace(/<!--/, '');
        content = content.replace(/-->/, '');
        content = doc._esc(content);
        content = content.replace(/\*\*\*\*([^*]*)\*\*\*\*/g, '<span class="hilite">$1</span>') ;
        return content ;
      };

      function updateDTD(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="dtd">' + doc._esc(content) + '</pre>';
        content = content.replace(/!ENTITY % ([^ \t\r\n]*)/g, '!ENTITY <span class="entity">% $1</span>');
        content = content.replace(/!ELEMENT ([^ \t$]*)/mg, '!ELEMENT <span class="element">$1</span>');
        return content;
      };

      function updateSchema(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="dtd">' + doc._esc(content) + '</pre>';
        content = content.replace(/&lt;xs:element\s+name=&quot;([^&]*)&quot;/g, '&lt;xs:element name="<span class="element" id="schema_element_$1">$1</span>"') ;
        return content;
      };

      function updateTTL(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="sh_sourceCode">' + doc._esc(content) + '</pre>';
        content = content.replace(/@prefix/g, '<span class="sh_keyword">@prefix</span>');
        return content;
      };

      var respecConfig = {
          // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "ld-patch",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI:           "http://berjon.com/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              {
                  name:       "Alexandre Bertails"
              ,   url:        "http://bertails.org/"
              ,   mailto:     "alexandre@bertails.org"
              ,   company:    "Pellucid Analytics"
              ,   companyURL: "http://www.pellucid.com"
              },
              {
                  name:       "Pierre-Antoine Champin"
              ,   url:        "http://liris.cnrs.fr/~pchampin/en/"
//              ,   mailto:     "@@@"
              ,   company:    "Université de Lyon"
//              ,   companyURL: "@@@"
              },
              {
                  name:       "Andrei Sambra"
              ,   url:        "https://deiu.rww.io/profile/card#me"
              ,   mailto:     "asambra@mit.edu"
              ,   company:    "MIT"
              ,   companyURL: "http://web.mit.edu"
              },
          ],

          // name of the WG
          wg:           "Linked Data Platform Working Group",
          
          // URI of the public WG page
          wgURI:        "http://www.w3.org/2012/ldp",
          
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-ldp-comments",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/Consortium/Patent-Policy-20040205/",
          // !!!! IMPORTANT !!!! MAKE THE ABOVE BLINK IN YOUR HEAD
          preProcess: [ preProc ]
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
Linked Data Patch Format (LD Patch) defines a language for expressing a sequence of operations to apply to a RDF Graph; it is suitable for use with the HTTP PATCH method. The "text/ldpatch" media type is used to identify such Patch documents.
      </p>
    </section>
    
    <section id='sotd'>
      <p>
        @@You need to have a custom SotD paragraph. Maybe give a succinct description of your spec's
        status.@@
      </p>
    </section>
    
    <section class='informative' id='introduction'>
      <h1>Introduction</h1>
      <p>
Linked Data "describes a method of publishing structured data so that it can be interlinked and become more useful. It builds upon standard Web technologies such as HTTP, RDF and URIs, but rather than using them to serve web pages for human readers, it extends them to share information in a way that can be read automatically by computers. This enables data from different sources to be connected and queried." (source Wikipedia).
      </p>
      <p>
This document defines the Linked Data Patch Format (LD Patch), a patch format for Linked Data. It is suitable for use with HTTP PATCH [@@RFC5789], a method to perform partial modifications to Web resources. The "text/ldpatch" media type is used to identify such LD Patch documents.
      </p>
      <p>
An instance of the LD Patch language (or LD Patch document) defines a list of operations to be performed against an RDF Graph. Operations include @@@. They operate on nodes and triples belonging to the graph.
      </p>
      <p>
        The following RDF Graph will be used as an example through this specification. It describes the relation between a person named Tim Berners-Lee (denoted by <code>&lt;http://example.org/timbl#&gt;</code>) and two events he attended.
      </p>
      <pre class='example'>
@prefix schema: &lt;http://schema.org/&gt; .
@prefix profile: &lt;http://ogp.me/ns/profile#&gt; .

&lt;http://example.org/timbl#&gt; a schema:Person ;
  schema:alternateName "TimBL" ;
  profile:first_name "Tim" ;
  profile:last_name "Berners-Lee" ;
  schema:workLocation [ schema:name "W3C/MIT" ] ;
  schema:attendee _:b1, _:b2 .

_:b1  ;
  schema:name "F2F5 - Linked Data Platform" ;
  schema:url &lt;https://www.w3.org/2012/ldp/wiki/F2F5&gt; .

_:b2 a schema:Event ;
  schema:name "TED 2009" ;
  schema:startDate "2009-02-04" .
  schema:url &lt;http://conferences.ted.com/TED2009/&gt; .
      </pre>
      <p>
The following is an example LD Patch document, transferred in an HTTP PATCH request:
      </p>
      <pre class='example'>
PATCH /timbl HTTP/1.1
Host: example.org
Content-Length: 478
Content-Type: text/ldpatch
If-Match: "abc123"

@prefix profile: &lt;http://ogp.me/ns/profile#&gt; .

Replace &lt;#&gt; profile:first_name 0> ( "Timothy" ) .

Bind ?event &lt;#&gt; /schema:attendee/[schema:url = &lt;http://conferences.ted.com/TED2009/&gt;]  .
Add ?event rdf:type schema:Event .

Bind ?ted &lt;http://conferences.ted.com/TED2009/&gt; /-schema:url! .
Delete ?ted schema:startDate "2009-02-04".
Add ?ted schema:location [
  schema:name "Long Beach, California";
  schema:geo [ schema:latitude "33.7817" ; schema:longitude "-118.2054" ] .
] .
      </pre>
      <p>
This example introduces many of features of the LD Patch format: @prefix and prefixed names, the @@@ operations, the Bind-ing mechanism, @@@.
      </p>
      <p>
The following is the resulting (patched) document.
      </p>
      <pre class='example'>
@prefix schema: &lt;http://schema.org/&gt; .
@prefix profile: &lt;http://ogp.me/ns/profile#&gt; .

&lt;http://example.org/timbl#&gt; a schema:Person ;
  schema:alternateName "TimBL" ;
  profile:first_name "Timothy" ;
  profile:last_name "Berners-Lee" ;
  schema:workLocation [ schema:name "W3C/MIT" ] ;
  schema:attendee _:b1, _:b2 .

_:b1  ;
  schema:name "F2F5 - Linked Data Platform" ;
  schema:url &lt;https://www.w3.org/2012/ldp/wiki/F2F5&gt; .

_:b2 a schema:Event ;
  schema:name "TED 2009" ;
  schema:url &lt;http://conferences.ted.com/TED2009/&gt; ;
  schema:location [
    schema:name "Long Beach, California";
    schema:geo [ schema:latitude "33.7817" ; schema:longitude "-118.2054" ] .
  ] .
      </pre>


    </section>

<!--      <p id='expressive-power'>
        The scope of LD Patch is intentionally limited when compared to SPARQL Update capabilities. Its expressive power is limited to (relative) RDF Graphs. Matching nodes is achieved using property paths. Nodes can be bound to variables. The language includes support for blank nodes and RDF Lists.
      </p>
      <p id='design-choices'>
        The authors of the document made conscious choices when designing the LD Patch language. Here are a few:
        <ul>
          <li>LD Patch was thought to be used in Linked Data applications. It is <strong>not</strong> designed for general purpose RDF applications.</li>
          <li>if more expressive power is desired, the authors recommends the use of SPARQL Update.</li>
          <li>LD Patch is not design to describe diffs between RDF Graphs: it is meants to be used in applications as a real patching language. That being said, it is strongly inspired from <a href="http://afs.github.io/rdf-patch/">RDF Patch</a> and is (mostly?) a superset.</li>
          <li>compatibity with SPARQL Update was not sought as there is no intention to make LD Patch's semantics a subset of SPARQL Update's. As a result, an LDP Patch instance is not a valid SPARQL update query.</li>
          <li>being able to match Blank Nodes is a desired and non-negociable property</li>
          <li>good performance characteristics of the operational semantics requires some trade-offs in the features of the language.</li>
          <li></li>
        </ul>
      </p>

-->

       
    <section class='informative' id='language-features'>
      <h1>LD Patch format</h1>
      <p>
A LD Patch document is made of a list of statements, where the order is relevant. Each statement either binds a variable to a set of matching nodes, or defines a modification on the graph.
      </p>
      <p>

      </p>
      <section>
        <h2><tdef>Prefixes</tdef></h2>
        <p>
LD Patch offers the possibility to abbreviate URIs by using Turtle's <i>@prefix</i> directive that allows declaring a short prefix name for a long prefix of repeated URIs. This is useful for many RDF vocabularies that are all defined in nearby namespace URIs, possibly using XML's namespace mechanism that works in a similar fashion.
        </p>
        <p>
Once a prefix such as <code>@prefix foo: &lt;http://example.org/ns#&gt;</code> is defined, any mention of a URI later in the document may use a qualified name that starts <code>foo:</code> to stand for the longer URI. So for example, the qualified name <code>foo:bar</code> is a shorthand for the URI <code>http://example.org/ns#bar</code>.
        </p>
      </section>
      <section>
        <h2><tdef>Path expressions</tdef></h2>
        <p>
LD Patch uses path expressions to offer possible routes through a graph between two graph nodes. A trivial case is a path expression of length 1, which is a triple pattern (@@Discuss). The ends of the path may be RDF terms or variables. Variables can not be used as part of the path itself, only as ends.
        </p>
        <p>
Path expressions allow for more concise graph patterns while also adding the ability to match connectivity of two resources by an arbitrary length path. Although similar to SPARQL's <a href="http://www.w3.org/TR/sparql11-query/#propertypaths" target="_blank">property paths</a>, path expressions are comprised of <tref>Step</tref>s and/or <tref>Constraint</tref>s.
        <pre class='example'>
/schema:attendee/[schema:url = &lt;http://conferences.ted.com/TED2009/&gt;]
        </pre>
        </p>
      </section>

      <section>
        <h2><tdef>Node matching semantics</tdef></h2>
        <p>

        </p>
      </section>

      <section>
        <h2><tdef>Pointed Graph</tdef></h2>
        <p>
Contrary to <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-named-graph" target="_blank">RDF named graphs</a> that are used to refer to documents by  syntactically pairing a URL with a graph, a pointed graph is an RDF graph with a pointer that denotes a "thing" described within the graph. It allows to traverse graphs of relations starting from a graph entity. An example of a pointed graph is the person to which the URI <code>http://example.org/timbl#</code> refers, and described by the triples contained in that graph.</p>
      </section>

      <section>
        <h2><tdef>Bind</tdef></h2>
        <p>
The Bind operation is used to create a new variable by binding or assigning an RDF Term to the variable. The bind variable has a global scope. Use of a given variable name anywhere in a query identifies the same variable. Following the example above, the Bind operation creates a new variable called <code>event</code>, starting from the RDF Term <code>&lt;#&gt;</code> and following the path expression <code>/schema:attendee/[schema:url = &lt;http://conferences.ted.com/TED2009/&gt;]</code> in order to identify the RDF Term to which this varible will point -- i.e. <code>_:b2</code>.
        <pre class='example'>
...
Bind ?event &lt;#&gt; /schema:attendee/[schema:url = &lt;http://conferences.ted.com/TED2009/&gt;] .
...
        </pre>
        </p>
        <p>
The Bind operation is defined by three components: <tref>Var</tref>, <tref>Value</tref> and <tref>Path</tref>, the last component being optional.
        </p>
        <p>
<tref>Var</tref> contains a unique name for the new variable. Variables are prefixed by "?"; the "?" character is not part of the variable name.
        </p>
        <p>
<tref>Value</tref> is the RDF Term that will be used as starting point when following the path expression.
        </p>
        <p>
<tref>Path</tref> is the expression that used to identify the RDF Term to which the Variable will point. It is comprised of <tref>Step</tref>s and/or <tref>Constraint</tref>s.
        </p>
      </section>

      <section>
        <h2><tdef>Add</tdef></h2>
        <p>
The Add operation is used to add or append new RDF Statements to the existing graph. To add new RDF Statements, the operation requires a <tref>Subject</tref>, a <tref>Predicate</tref> and either an <tref>Object</tref> or a <tref>List</tref>.
        <pre class='example'>
...
Add ?event rdf:type schema:Event .
...
        </pre>
        </p>
      </section>

      <section>
        <h2><tdef>Delete</tdef></h2>
        <p>
The Delete operation can only be used to remove a single RDF Statement from the existing graph. The syntax for the Delete operation requires a <tref>Subject</tref>, a <tref>Predicate</tref> and an <tref>Object</tref>.
        <pre class='example'>
...
Delete ?ted schema:startDate "2009-02-04".
...
        </pre>
        </p>
      </section>

      <section>
        <h2><tdef>Replace</tdef></h2>
        <p>
The Replace operation is used to update one or more <tref>Object</tref>s in an RDF Statement by providing an RDF <tref>List</tref> of one or more <tref>Object</tref>s. 
        <pre class='example'>
...
Replace &lt;#&gt; profile:first_name 0> ( "Timothy" ) .
...
        </pre>
        </p>
      </section>

    </section>


    <section id='concrete-syntax'>
      <h1>Concrete Syntax</h1>
      <p>
      </p>
      <pre>
<tdef>LDPatch</tdef> ::= Prologue Statement*
<tdef>Prologue</tdef> ::= <tref>Prefix</tref>*
<tdef>Prefix</tdef> ::= "Prefix" PNAME_NS IRIREF
<tdef>Statement</tdef> ::= <tref>Bind</tref> | <tref>Add</tref> | <tref>Delete</tref> | <tref>Replace</tref>
<tref>Bind</tref> ::= "Bind" <tref>Var</tref> <tref>Value</tref> <tref>Path</tref>?
<tref>Add</tref> ::= "Add" <tref>Subject</tref> <tref>Predicate</tref> ( <tref>Object</tref> | <tref>List</tref> )
<tref>Delete</tref> ::= "Delete" <tref>Subject</tref> <tref>Predicate</tref> <tref>Object</tref>
<tref>Replace</tref> ::= "Replace" <tref>Subject</tref> <tref>Predicate</tref> <tref>Slice</tref> <tref>List</tref>

<tdef>Subject</tdef> ::= <tref>iri</tref> | <tref>BlankNode</tref> | <tref>Var</tref>
<tdef>Predicate</tdef> ::= <tref>iri</tref>
<tdef>Object</tdef> ::= <tref>iri</tref> | <tref>BlankNode</tref> | <tref>literal</tref> | <tref>Var</tref>
<tdef>Value</tdef> ::= <tref>iri</tref> | <tref>literal</tref> | <tref>Var</tref>
<tdef>List</tdef> ::= '(' <tref>Object</tref>* ')'

<tref>Path</tref> ::= ( <tref>Step</tref> | <tref>Constraint</tref> )*
<tdef>Step</tdef> ::= '/' ( '-' <tref>iri</tref> | <tref>iri</tref> | <tref>INDEX</tref> )
<tdef>Constraint</tdef> ::= '[' <tref>Path</tref> ( '=' <tref>Value</tref> )? ']' | '!'

<tdef>Slice</tdef> ::= <tref>INDEX</tref>? '&gt;' <tref>INDEX</tref>?
<tdef>INDEX</tdef> ::= [0-9]+

// copied from SPARQL

// supposed to be `Var ::= VAR1 | VAR2` but here only VAR1
<tref>Var</tref> ::= '?' <tref>VARNAME</tref>
<tdef>VARNAME</tdef> ::= ( <tref>PN_CHARS_U</tref> | [0-9] ) ( <tref>PN_CHARS_U</tref> | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*

// copied from Turtle

<tref>Literal</tref> ::= <tref>RDFLiteral</tref> | <tref>NumericLiteral</tref> | <tref>BooleanLiteral</tref>
<tdef>NumericLiteral</tdef> ::= <tref>INTEGER</tref> | <tref>DECIMAL</tref> | <tref>DOUBLE</tref>
<tdef>RDFLiteral</tdef> ::= <tref>String</tref> (<tref>LANGTAG</tref> | '^^' <tref>iri</tref>)?
<tdef>BooleanLiteral</tdef> ::= 'true' | 'false'
<tref>String</tref> ::= <tref>STRING_LITERAL_QUOTE</tref> | <tref>STRING_LITERAL_SINGLE_QUOTE</tref> | <tref>STRING_LITERAL_LONG_SINGLE_QUOTE</tref> | <tref>STRING_LITERAL_LONG_QUOTE</tref>
<tref>iri</tref> ::= <tref>IRIREF</tref> | <tref>PrefixedName</tref>
<tdef>PrefixedName</tdef> ::= <tref>PNAME_LN</tref> | <tref>PNAME_NS</tref>
<tref>BlankNode</tref> ::= <tref>BLANK_NODE_LABEL</tref> | <tref>ANON</tref>
<tdef>IRIREF</tdef> ::= '&lt;' ([^#x00-#x20&lt;&gt;"{}|^`\] | <tref>UCHAR</tref>)* '&gt;' /* #x00=NULL #01-#x1F=control codes #x20=space */
<tdef>PNAME_NS</tdef> ::= <tref>PN_PREFIX</tref>? ':'
<tdef>PNAME_LN</tdef> ::= <tref>PNAME_NS</tref> <tref>PN_LOCAL</tref>
<tdef>BLANK_NODE_LABEL</tdef> ::= '_:' (<tref>PN_CHARS_U</tref> | [0-9]) ((<tref>PN_CHARS</tref> | '.')* <tref>PN_CHARS</tref>)?
<tdef>LANGTAG</tdef> ::= '@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*
<tdef>INTEGER</tdef> ::= [+-]? [0-9]+
<tdef>DECIMAL</tdef> ::= [+-]? [0-9]* '.' [0-9]+
<tdef>DOUBLE</tdef> ::= [+-]? ([0-9]+ '.' [0-9]* <tref>EXPONENT</tref> | '.' [0-9]+ <tref>EXPONENT</tref> | [0-9]+ <tref>EXPONENT</tref>)
<tdef>EXPONENT</tdef> ::= [eE] [+-]? [0-9]+
<tdef>STRING_LITERAL_QUOTE</tdef> ::= '"' ([^#x22#x5C#xA#xD] | <tref>ECHAR</tref> | <tref>UCHAR</tref>)* '"'      /* #x22=" #x5C=\ #xA=new line #xD=carriage return */
<tdef>STRING_LITERAL_SINGLE_QUOTE</tdef> ::= "'" ([^#x27#x5C#xA#xD] | <tref>ECHAR</tref> | <tref>UCHAR</tref>)* "'"      /* #x27=' #x5C=\ #xA=new line #xD=carriage return */
<tdef>STRING_LITERAL_LONG_SINGLE_QUOTE</tdef> ::= "'''" (("'" | "''")? ([^'\] | <tref>ECHAR</tref> | <tref>UCHAR</tref>))* "'''"
<tdef>STRING_LITERAL_LONG_QUOTE</tdef> ::= '"""' (('"' | '""')? ([^"\] | <tref>ECHAR</tref> | <tref>UCHAR</tref>))* '"""'
<tdef>UCHAR</tdef> ::= '\\u' <tref>HEX</tref> <tref>HEX</tref> <tref>HEX</tref> <tref>HEX</tref> | '\\U' <tref>HEX</tref> <tref>HEX</tref> <tref>HEX</tref> <tref>HEX</tref> <tref>HEX</tref> <tref>HEX</tref> <tref>HEX</tref> <tref>HEX</tref>
<tdef>ECHAR</tdef> ::= '\' [tbnrf"'\]
<tdef>WS</tdef> ::= #x20 | #x9 | #xD | #xA /* #x20=space #x9=character tabulation #xD=carriage return #xA=new line */
<tdef>ANON</tdef> ::= '[' <tref>WS</tref>* ']'
<tdef>PN_CHARS_BASE</tdef> ::= [A-Z] | [a-z] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF] | [#x0370-#x037D] | [#x037F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
<tdef>PN_CHARS_U</tdef> ::= <tref>PN_CHARS_BASE</tref> | '_'
<tdef>PN_CHARS</tdef> ::= <tref>PN_CHARS_U</tref> | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]
<tdef>PN_PREFIX</tdef> ::= <tref>PN_CHARS_BASE</tref> ((<tref>PN_CHARS</tref> | '.')* <tref>PN_CHARS</tref>)?
<tdef>PN_LOCAL</tdef> ::= (<tref>PN_CHARS_U</tref> | ':' | [0-9] | <tref>PLX</tref>) ((<tref>PN_CHARS</tref> | '.' | ':' | <tref>PLX</tref>)* (<tref>PN_CHARS</tref> | ':' | <tref>PLX</tref>))?
<tdef>PLX</tdef> ::= <tref>PERCENT</tref> | <tref>PN_LOCAL_ESC</tref>
<tdef>PERCENT</tdef> ::= '%' <tref>HEX</tref> <tref>HEX</tref>
<tdef>HEX</tdef> ::= [0-9] | [A-F] | [a-f]
<tdef>PN_LOCAL_ESC</tdef> ::= '\' ('_' | '~' | '.' | '-' | '!' | '$' | '&amp;' | "'" | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%')
      </pre>
    </section>

    <section id='abstract-syntax'>
      <h1>Abstract Syntax</h1>
      <p>
The LD Patch data model makes use of the commonly defined <a href="http://en.wikipedia.org/wiki/Abstract_data_type">Abstract Data Types</a> <a href="http://en.wikipedia.org/wiki/Set_(computer_science)">Set</a>, <a href="http://en.wikipedia.org/wiki/List_(computer_science)">List</a> and <a href="http://en.wikipedia.org/wiki/Option_type">Option</a>, used here as type constructors. For example, <code>Set(A)</code> denotes the type for the sets of elements of type <code>A</code>. We assume that they come with their common operations, such as the function <code>size&nbsp;:&nbsp;Set&nbsp;→&nbsp;Int</code>.					
      </p>
      <pre>
<tref>LDPatch</tref> ::= <tref>List</tref>(<tref>Statement</tref>)

<tref>Statement</tref> ::= <tref>Add</tref> | <tref>AddList</tref> | <tref>Delete</tref> | <tref>Bind</tref> | <tref>Replace</tref>
<tref>Add</tref>       ::= (<tref>Subject</tref>, <tref>Predicate</tref>, <tref>Object</tref>)
<tdef>AddList</tdef>   ::= (<tref>Subject</tref>, <tref>Predicate</tref>, <tref>List</tref>(<tref>Object</tref>))
<tref>Delete</tref>    ::= (<tref>Subject</tref>, <tref>Predicate</tref>, <tref>Object</tref>)
<tref>Bind</tref>      ::= (<tref>Var</tref>, <tref>Value</tref>, <tref>Path</tref>)
<tref>Replace</tref>   ::= (<tref>Subject</tref>, <tref>Predicate</tref>, <tref>Slice</tref>, <tref>List</tref>(<tref>Object</tref>))

<tdef>Path</tdef>         ::= <tref>List</tref>(<tref>PathElement</tref>)
<tdef>PathElement</tdef>  ::= <tref>Step</tref> | <tref>Constraint</tref>
<tref>Step</tref>         ::= <tref>StepForward</tref> | <tref>StepBackward</tref> | <tref>StepAt</tref>
<tref>Constraint</tref>   ::= <tref>Filter</tref> | UNICITY_CONSTRAINT
<tdef>StepForward</tdef>  ::= <tref>IRI</tref>
<tdef>StepBackward</tdef> ::= <tref>IRI</tref>
<tdef>StepAt</tdef>       ::= <tref>Integer</tref>
<tdef>Filter</tdef>       ::= (<tref>Path</tref>, Option(<tref>Value</tref>))

<tref>Slice</tref>            ::= <tref>Range</tref> | <tref>EverythingBefore</tref> | <tref>EverythingAfter</tref> | END
<tdef>Range</tdef>            ::= (<tref>Integer</tref>, <tref>Integer</tref>)
<tdef>EverythingBefore</tdef> ::= <tref>Integer</tref>
<tdef>EverythingAfter</tdef>  ::= <tref>Integer</tref>

<tref>Subject</tref>   ::= <tref>IRI</tref> | <tref>BlankNode</tref> | <tref>Var</tref>
<tref>Predicate</tref> ::= <tref>IRI</tref>
<tref>Object</tref>    ::= <tref>IRI</tref> | <tref>BlankNode</tref> | <tref>Literal</tref> | <tref>Var</tref>
<tref>Value</tref>     ::= <tref>IRI</tref> | <tref>Literal</tref> | <tref>Var</tref>

<tdef>Var</tdef>       ::= <tref>String</tref>
<tdef>IRI</tdef>       ::= RDF URI-reference http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#section-IRIs as subsequently restricted by SPARQL http://www.w3.org/TR/rdf-sparql-query/#docTerminology
<tdef>BlankNode</tdef> ::= RDF blank node http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#section-blank-nodes
<tdef>Literal</tdef>   ::= RDF Literal http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#section-Graph-Literal
<tdef>String</tdef>    ::= a Unicode String
      </pre>

    </section>
    
    <section id='operational-semantics'>
      <h1>Operational Semantics</h1>
      <p>
The denotational RDF semantics makes use of the <a href="http://en.wikipedia.org/wiki/Set-builder_notation">set-builder notation</a> for building the RDF sets.
      </p>
<!--pre>An Env(ironment) is a Map from Var-s to Node-s
Env      ::= Map(Var, Set(Node))

TBD
---

env[x]
env[x -> nodes]

matchTriples: Graph -> Option(Node) -> Uri -> Option(Node) -> Set((Node, Uri, Node))
matchTriples: (g: Graph) -> (s: Option(Node)) -> (p: Uri) -> (o: Option(Node)) -> { matchingTriples: Set((Node, Uri, Node)) | triple matches the pattern (s, p, o) in g -> triple ∈ matchingNodes }

+: Graph -> Set(Triple) -> Graph

-: Graph -> Set(Triple) -> Graph

sem functions
-------------

sem_varOrConcreteNode is a function that maps a Var to a Node or a ConcreteNode to itself
sem_varOrConcreteNode: Env -> VarOrConcreteNode -> Set(Node)
sem_varOrConcreteNode(env, v: Var) = env[v]
sem_varOrConcreteNode(env, uri: Uri) = Set(uri)
sem_varOrConcreteNode(env, literal: Literal) = Set(literal)

sem_matchingNodes: Graph -> Set(Node) -> Path -> Set(Node)
sem_matchingNodes(graph, nodes, List()) = nodes
sem_matchingNodes(graph, nodes, (Forward, uri, mode) :: restPath) =
  let triples = { matchTriples(graph, node, uri, ANY) | node ∈ nodes } in
  let matchingNodes = { o | (s, p, o) ∈ triples } in
  if mode is Single and size(matchingNodes) is not 1 then throw error
  sem_matchingNodes(graph, matchingNodes, restPath)
sem_matchingNodes(graph, nodes, (Backward, uri, mode) :: restPath) =
  let triples = { matchTriples(graph, ANY, uri, node) | node ∈ nodes } in
  let matchingNodes = { s | (s, p, o) ∈ triples } in
  if mode is Single and size(matchingNodes) is not 1 then throw error
  sem_matchingNodes(graph, matchingNodes, restPath)

makeTriples: Set(Node) -> OrientedPredicate -> Node -> Set(Triple)
makeTriples(nodes, (Forward, uri), node) =
  { (n, uri, node) | n ∈ nodes }
makeTriples(nodes, (Backward, uri), node) =
  { (node, uri, n) | n ∈ nodes }


sem_bind: (Env, Graph) -> Bind -> (Env, Graph)
sem_bind((env, graph), Bind(start, path, v)) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in
  (env[v -> nodes], graph)

sem_add: (Env, Graph) -> Add -> (Env, Graph)
sem_add((env, graph), Add(start, path, orientedPredicate, (node, pgTriples))) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in  
  let triples = makeTriples(nodes, orientedPredicate, node) in
  (env, graph + triples + pgTriples)


sem_delete: (Env, Graph) -> Delete -> (Env, Graph)
sem_delete((env, graph), Delete(start, path, orientedPredicate, None)) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in
  let triples = { matchTriples(graph, node, orientedPredicate, None) | node ∈ nodes } in
  (env, graph - triples)
sem_delete((env, graph), Delete(start, path, orientedPredicate, Some((node, pgTriples)))) =
  let nodes = sem_matchingNodes(sem_varOrConcreteNode(graph, env, start), path) in
  let triples = { matchTriples(graph, node, orientedPredicate, Some(node)) | node ∈ nodes } in
  (env, graph - triples - pgTriples)

sem_cut: (Env, Graph) -> Cut -> (Env, Graph)
sem_cut((env, graph), Cut(varOrConcreteNode)) =
  let nodes = sem_varOrConcreteNode(graph, env, varConcreteNode) in
  let triples = connectedGraph(nodes) in
  (env, graph = triples)


connectedGraph: Graph -> Set(Node) -> Set(Triple)
connectedGraph(graph, nodes) =
  let f(triples) = { matchingTriples(o, None, None)  | (s, p, o) ∈ triples } in
  fixpoint f


sem_update: (Env, Graph) -> Update -> (Env, Graph)
sem_update((env, graph), Update(varOrConcreteNode, (pgNode, pgTriples))) =
  let nodes = sem_varOrConcreteNode(graph, env, varOrConcreteNode) in
  let incomingTriples = { matchingTriples(None, None, node) | node ∈ nodes } in
  let newIncomingTriples = { (s, p, pgNode) | (s, p, _) ∈ incomingTriples } in
  let connectedTriples = connectedGraph(nodes) in
  (env, graph - incomingTriples - connectedTriples + newIncomingTriples + pgTriples)

sem_patch: Graph -> List(Statement) -> Graph
sem_patch(g, statements) = sem_patch_state(({}, g), statements)

sem_statement: (Env, Graph) -> Statement -> (Env, Graph)
sem_statement(state, bind: Bind) = sem_bind(state, bind)
sem_statement(state, add: Add) = sem_bind(state, add)
sem_statement(state, delete: Delete) = sem_bind(state, delete)
sem_statement(state, update: Update) = sem_bind(state, update)

sem_patch_state: (Env, Graph) -> List(Statement) -> Graph
sem_patch_state((env, graph), List()) = graph
sem_patch_state(state, statement :: restStatements) =
  let newState = sem_statement(state, statement) in
  sem_patch_state(newState, restStatements)




TODO:
* runtime error
* parsing error
* grammar
* lists
* examples
* best practices

        </pre-->
    </section>
    

  </body>
</html>
